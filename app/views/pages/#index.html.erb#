<!--  hidden by JS -->
<!--  .js-test-hidden -->
<div class="js-test-hidden">
  <h1>YOU DON"T HAVE JAVASCRIPT, WHICH IS REQUIRED FOR FUNCTIONAL LINKS & CONTENT REORDERING</h1>
</div>

<div class="header">
  <section class="intro">
    <b> Max Pleaner </b> <br><br>
    <i> <small>Web Developer / Software Engineer </small></i>
  </section>
  <br>
  <hr>
  <br>
  <section class="primary-links">
    <a class="clickable" data-target="skills" href="#skills">Skills</a>
    <a class="clickable" data-target="experience" href="#experience">Experience</a>
    <a class="clickable" data-target="links" href="#links">Links</a>
  </section>
   <br>
</div>

<!--  .focus-area-1 -->
<!--  .focus-area-2 -->
<section class="focus-area-1"></section><br>
<section class="focus-area-2"></section>

<!--  .skills -->
<!--  .clickable -->
<!--  data-target -->
<section class="skills" id="skills">
  <p><b>Skills</b></p> <br>
  <a class="clickable" data-target="ruby" href="#skills/ruby">Ruby</a>
  <a class="clickable" data-target="javascript" href="#skills/javascript">Javascript</a>
  <a class="clickable" data-target="css" href="#skills/css">HTML/ CSS</a>
  <a class="clickable" data-target="databases" href="#skills/databases">Databases</a>
  <a class="clickable" data-target="deployment" href="#skills/deployment">Deployment</a>
  <a class="clickable" data-target="testing" href="#skills/testing">Testing</a>
  <a class="clickable" data-target="linux" href="#skills/linux">Linux</a>
  <a class="clickable" data-target="world" href="#skills/world">The World
   at Large</a>
</section>

<!--  .skill-details -->
<section class="skill-details">
  <section class="ruby" id="ruby">
    <p><b>Ruby</b></p> <br>
    <p>
      <pre>
        I recall when I was just starting out programming when I read that the Ruby
        community was the type to give a lot of hugs. I think this is a little far
        fetched, but does illustrate some characteristics of the language. The
        coziness of hugs reflects the smaller size of Ruby's developer community,
        not just in comparison to C and Java but also Python, the latter of which
        Ruby shares a very similar syntax with.

        The friendiness of hugs reflects the readability of Ruby. I  haven't seen any
        sucod that maintains aI ap poetic natural language sensibility in the way Ruby
        does. Some insist that this comes at a price. For example, Ruby's "<a href="http://en.wikipedia.org/wiki/Duck_typing
">duck-typing</a>"
        system can be seen as allowing errors to propagate unnecessarily farther
        than where they originated. It allows for a lot less redundancy, though,
        if the reader/author can keep track of variable types. I've found Ruby's
        stack traces to be quite comprehendable, though.

        <a href="https://news.ycombinator.com/item?id=682101">Here</a> is a Hacker News thread comparing Python with Ruby. There's a lot
        of bickering about minute syntax details, but I think there's a salient
        differentiation described between Python's "conservative" nature and Ruby's
        "experimental" one. I think this partly reflects Python's age and history
        of integration with enterprise / non-web application in comparison to Ruby's
        more particular association with the web, since Ruby became popular with Rails.
        I've began learing Python, but for what I'm mainly using Ruby for, web apps,
        I'm generally finding myself using my time to learn Node / Javascript instead.
        The "cutting edge" sentiment aside, single-page-app features have become an
        expected convenience for users.

        <i><b>A list of some tools I use when writing Ruby:</b></i>

        <b><a href="http://rubyonrails.org/">Rails</a></b>

          Rails is the web framework I'm quickest and most fluent in.
          I don't think Rails is the end-all for web development. With more fluency,
          I'm sure I could write a complex single-page app faster with a Node framework.
          For mostly everything besides asynchronous server calls and client-side page
          navigation, though, I'm quickest with Rails.

          A few topics of Rails development worth highlighting:

            <b> Auth </b>- Session tokens, authenticity tokens, and encrypted passwords
              can be be added to Rails rather quickly - One App Academy assessment was
              to set the system up within 15 minutes. There are also gems like <a href="https://github.com/plataformatec/devise">Devise</a>
              which add this functionality, and OAuth libraries for many providers. I'm
              also interested to try the more minimalist <a href="https://github.com/NoamB/sorcery">Sorcery</a> auth library.
              There can be a lot that goes into a complex auth system - email confirmation,
              password retrieval, etc. Gems like Devise help with this.

            <b> Code Organization</b> -  At first, the default Rails project directory
              structure struck me as somewhat daunting, especially for sections relating
              to features I wasn't sure I'd use. I've since come to appreciate the
              'convention over configuration' approach,  which enhances components'
              portability among projects.

            <b> Generators</b> - <code> rails new </code> is a generator for a new
              project. For some projects (like this site, which is mainly HTML, CSS
              and JS), this is nearly all the code the server needs in development
              mode. There are also generators for models, controllers, database
              migrations, <a href="http://en.wikipedia.org/wiki/Rake_%28software%29">rake tasks</a>, and, my favorite, <code>scaffold</code>s, which produce
              a working <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> app with front-end. Generators excite me not just because of
              laziness but also because of their potential to facilitate
              metaprogramming. There's even a project called <a href="http://prelang.com/">Prelang</a> which
              lets you describe your app's specs in a web interface and generates
              a rails project for you. <a href="http://www.meteorkitchen.com/">Meteor Kitchen</a> is a similar tool for Javascript.

        <a href="http://www.sinatrarb.com/">Sinatra</a>

          Sinatra shares a lot in common with Rails but is much more minimalist. Learning
          Sinatra taught me that Rails is not the only smart choice for web development
          in Ruby. It's less 'opinionated' than Rails, and since projects are built more
          from-the-ground-up, there's less deconstruction required to change out core
          components. It was in this context that I found <a href="http://datamapper.org/">DataMapper</a>, a plug-n-play,
          migration-less alternative to Rails' <a href="http://guides.rubyonrails.org/active_record_basics.html">ActiveRecord</a> database library. I usally
          choose Rails for new projects, but learning Sinatra has inspired me to take
          occasional forays into building minimalist Ruby web frameworks and
          helped me appreciate the modular aspects of well-constructed Ruby gems.
          Sinatra's routing pattern, <code>get ("/") { puts "hello world" }</code>, is found
          in lots of Ruby's web "microframeworks".

        <a href="http://www.rubygems.org/">Gems</a>

          Gems are Ruby's plugin system, managed with <a href="https://rvm.io/">RVM</a> (or <a href="https://github.com/sstephenson/rbenv">rbenv</a>), <a href="https://rubygems.org/">RubyGems</a>, <a href="http://bundler.io/">Bundler</a>, etc.
          Interesting gems are constantly coming out. The site <a href="http://gembundle.com">GemBundle</a> is useful for
          discovering them.

          Here are a few I like:
        <span><span>
            <a href="https://github.com/defunkt/colored">Colored</a>
              This Gem enables string methods like <code>"string".red</code>, <code>"string".bold.underline</code>,
              <code>"string".white_on_red</code>, etc. It uses <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">ANSI Escape Codes</a> (ANSI stands for
              American National Standards Institute) so the text appears
              colored when it's printed in the terminal. The actual text saved
              to file, though, is wrapped in characters which aren't meant to
              be read my people. For example, <code>"string".red</code> would produce <code>\e[31mstring\e[0m</code>).
              Most of the time when I make CLI applications, I use this gem.
              There's also a Javascript library called <a href="https://github.com/drudru/ansi_up">Ansi Up</a> which converts
              ANSI-encoded text into <code>span</code> elements with corresponding
              CSS coloring. Together they make an easy way to define styles
              from the server.

              Examples:
                <span class="ansi"><%= ".red_on_yellow".red_on_yellow %></span>
                <span class="ansi"><%= ".green_on_black".green_on_black %></span>
          </span><span>
            <a href="https://github.com/deivid-rodriguez/byebug">Byebug</a>
              This makes it possible to place breakpoints in code and step
              through, inspecting values and running code in a REPL. It is
              similar to the "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">debugger</a>" breakpoint tool for Javascript
              in major browsers. There are also powerful features I haven't
              used, such as changing source code on-the-fly. It's vast
              improvement to debugging with "puts" statements.
          </span><span>
            <a href="https://github.com/rails/rails/tree/master/activesupport">ActiveSupport</a>
              This gem is built into Rails, but I frequently use it in non-Rails projects
              with <code>require 'active_support/all'</code> so that I can use string methods like
              <code>capitalize</code>, <code>pluralize</code>, <code>singularize</code>, and <code>constantize</code>.

              For example:
              <code>
  class Light
    def on
      puts "light is on"
    end
  end
  "lights".singularize.capitalize.constantize.new.on
  # => "light is on"
            </code>

              It might seem pointless to do this instead of <code>Light.new.on</code>,
              but there are other use-cases for these methods. Methods can be
              activated from symbols (via <code>send</code>), and any string can be
              converted to symbol (<code>:"Some #{'long_string'} Symbol"</code> is 
              still a symbol, in fact). Strings can also be passed to get and set
              instance variables, like <code>User.new.send("@name=", "Max")</code>
              (which will set the User's 'name' instance variable to Max. Such
              tools might seem flashy instead of useful, but the Ruby language favors
              the <a href="http://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it">tmtowtdi</a> approach (there's more than one way to do it),
              and despite their cryptic looking syntax, metaprogramming methods can 
              help write <a href="http://en.wikipedia.org/wiki/Domain-specific_language">Domain Specific Langauges</a> which are even more
              readable than regular Ruby code.
          </span><span>
            <a href="http://opalrb.org/">Opal</a>
              I haven't actually used this much, but I think it's very interesting.
              Opal compiles Ruby to Javascript and can even compile to Javascript
              libraries like jQuery. <a href="http://voltframework.com/">Volt</a> is a framework built with Opal that
              features <a href="http://stackoverflow.com/questions/13504906/what-is-two-way-binding">2-way-data binding</a> and that I'm eager to look into more.
          </span><span>
              <a href="https://github.com/rest-client/rest-client">Rest Client</a>
              HTTP requests and responses carry the data which is used
              by browsers to interpret websites' code on users' (clients')
              computers. Users normally have no reason to compose HTTP requests, but
              developers often do as a means of communicating with the
              web without a browser. RestClient helps configure HTTP
              methods (with an emphasis on the  <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">Representational State Transfer</a> 
              design pattern), including parameters, headers, etc.

              A basic example is <code>RestClient.get("http://wikipedia.com")</code>, which
              will give a text version of the file a browser would receive if the url were
              entered in the address bar. I'm not sure a Gem is really necessary for this
              functionality, since Ruby's standard library has <code>open-uri</code> which I'm
              pretty sure I could have used anywhere I used RestClient (the same goes for
              <a href="https://github.com/jnunemaker/httparty">HTTParty</a>). Most of the time I have used this in conjunction with Nokogiri, but
              it's itself useful as an alternative to Curl.
          </span> <span>
            <a href="https://github.com/nokogiri/nokogiri">Nokigiri</a>
              Basically jQuery for the Ruby server
              The <code>Nokigiri.parse(html).css</code> method allows for selecting objects from
              the DOM like <code>$('.some-css-class')</code> does. It's useful for web scraping.
          </span>
        </span>



      </pre>
    </p>
  </section>

  <section class="javascript" id="javascript">
    <p><b>Javascript</b></p> <br><pre>
        I've been learning & working with Javascript since soon after I began programming.
        Javascript offers some benefits and drawbacks in comparison to Ruby.

        First, one drawback - the language is is some ways a bit more primitive than Ruby. Alot
        of convenience methods in Ruby (<code>map</code> and <code>reject</code> for example)
        aren't defined in plain JS. They are defined in libraries like <a href="#underscore-url">underscore</a>, though.

        Next, a benefit - Javascript has a better system for passing around functions
        as arguments ("callbacks"). In Ruby, there are special types / keywords for this -
        <code>yield</code>, <code>Proc</code>, <code>Lambda</code>, etc. In Javascript, though, what's passed around is identical to a
        normal method. Another benefit of Javascript is the open access to define attributes on
        arbitrary objects. It's be like if Objects in Ruby were by default <code>OpenStruct</code>
        objects.

        Also, a less nuanced benefit is clearly the access JS has to the DOM. This
        is ubiquitous to Javascript, and a conventional complex web app will certainly
        use Javascript for the front-end.

        Some topics in Javascript that I have experience with -

        <b> <a href="#jquery-url">jQuery</a></b>
          A very useful abstraction for DOM methods. As I understand it, anything
          in jQuery can be written with plain Javascript without <i> too </i> much
          more effort (some are adament that jQuery should be avoided) - see
          <a href="http://youmightnotneedjquery.com">here</a> for jQuery / Javascript equivalents, but I (and many others) find it a
          valuable time-saver. <a href="http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014">jQuery's blog</a> reports that it's used by 60% of
          the top 100,000 websites.

          Some features I find particularly useful:

              <code>$.AJAX</code> (or <code>$.get</code>, <code>$.post</code>, etc.)
              For making AJAX to the server.

              <code>$.('.css-selector')</code>
              One can select using class, ID or attribute, replacing Javascript's
              <code>document.getElementByID</code>, <code>document.getElementsByClassName</code> or <code>document.querySelector</code>.

              <code>$(".some-element").on("some-event", function(event) { ... event code ... })</code>
              Event handlers. For <code>click</code>, <code>hover</code>, <code>submit</code>,
              window scrolling, etc.

              <code>$(".some-element").hide().show().fadeOut().fadeIn()</code>
              CSS effects & transitions.

              <code>clone()</code>, <code>remove()</code>, and <code>empty()</code>
              are among the many other useful methods.

        <b>
          <a href="#coffeescript-url">Coffeescript</a> </b>

          Coffeescript compiles to Javascript. Unlike SASS, which
          compiles to CSS but accepts any CSS as valid, plain Javascript
          wouldn't be valid in Coffeescipt. There are easy free programs
          to convert betwen the formats, though, such as <a href="#js-coffee-converter-url">this</a> one.

          Coffeescript's syntax is meant to be less verbose than Javascripts.
          It ends up looking more similar to Python or Ruby.
          Features distinguishing it from Javascript include -
            - many parentheses (<code>()</code>)are optional, as are
              curly brackets (<code>{}</code>).
            - Indentation is used to delimit blocks / scope (as in Python).
            - there is a shorthand for functions that is similar to
              Ruby's lambda shorthand - <code> ->(args) { ... fn body ... }</code>
            - No need for commas to separate attributes of objects.
        </b>
        <b>
          <a href="#backbone-url">Backbone</a></b>

          Backbone is a client-side MVC which I have experience
          building on top of Rails for a number of apps. I learned Backbone
          at App Academy, and doing so dramatically improved my skills
          at building single-page-apps.

          There are a lot of Javascript MVC frameworks, and Backbone seems to
          be a relatively minimalist, open-ended choice in comparison to
          Angular or Meteor.

          Here's how I use Backbone, in summary:

          - The <a href="#backbone-on-rails-url">backbone-on-rails</a> gem provides a
            <code>rails generate backbone:install</code> command which sets up a basic
            directory structure and some boilerplate code. Mostly everything lives in
            the app/assets/javascripts directory.
          - Add routes to the Backbone router file. These routes are navigatable via the url
            fragment (the same as this site, which doesn't use Backbone).
          - Set up backbone view files and templates. The templates are HTML, and
            embedded Javascript (<a href="#ejs-url">EJS</a>) can be used for more versitility.
          - Backbone views are like the controllers of MVC, but offer more than Rails'
            controllers since there is the expectation of complex client-side interactivity.
            Events are registered in a clean DSL (<code>events: {"click button.upvote": sendUpvote }</code>)
          - At App Academy, one assignement was to put together a subview system. The module
            we came up with is very easy to plug into projects, and using subviews adds a lot
            of modular control over front-end components. There also libraries such as <a href="#marionette-url">Marionette</a>
            for subviews in Backbone.

          A major main benefit of single-page-apps is the ability for clients to interact with
          servers (and see the effects in their browsers) in a stateful manner - eliminating the
          need for a full page reload whenever a button is clicked, for example. AJAX (or WebSockets, etc)
          is used to send HTTP requests in the background, and rather than having to reload the entire site
          (caching via something like <a href="#turbolinks-url">Turbolinks</a>aside), only the updated
          information is changed. This brings the behavior of native apps to the web.

        </b>
        <b>
          <a href="#meteor-url">Meteor</a>
        </b>
          I've began learning and building with Meteor since it offers an integrated server-client system
          which is intended for single-page-app development (Rails <a href="#dhh-spa-url">has been criticized</a> for not
          focusing on Javascript integration).

          This isn't unique to Meteor. The <a href="#mean-url">MEAN</a> stack is more widely used and
          integrates an <a href="#angular-url">Angular</a> front-end with <a href="#express">Express</a> /
          <a href="#mongo-url">MongoDB</a> backend running on Node. Meteor entices me becuase of it's
          comprehensive approach (everything "in the box", though, and emphasis on reducing boilerplate for client-server
          communication and <a href="#dom-url">DOM</a> updates. Meteor's team creates it's own
          data communiction protocol (<a href="ddp-url">DDP</a>) for <a href="#2-way-binding-url">two-way data binding</a>.

          The single-page-app environment is growing rapidly and is accompanied by the development
          of many different frameworks. I can't help but pay attention to the seeming politics of them.
          Angular's development is <a href="#angulr-funding-url">funded by Google</a>, and <a href="#react-url">React</a> by
          Facebook. Meteor comes across as trying to insulate the developer from a myriad of options. They offer freemium hosting
          and there is a Meteor-only package manager built on top of NPM, called <a href="#meteorite-url">Meteorite</a>. In the
          competitive atmosphere, though, surely frameworks will continue to "one-up" each other for some time.
          
          I have been really impressed by Meteor's packages and their plug-n-play character.
          To add authentication via password or OAuth provider, simply adding a meteor package
          like <code>meteor add accounts-password</code> or <code>meteor add accounts-github</code>
          will set up the backend and one can add a front-end with only <code>meteor add accounts-ui</code>
          and <code>{{>loginButtons }}</code>

        </b>
        <b>
          <a href="#npm">NPM</a>
        </b>

          NPM stands for "Node Package Manager" and is akin to gems in Ruby in many ways.
          "Installing packages" installs software to the computer. For some packages, this
          is as simple as downloading a small directory of Javascript files. For others, which
          require deeper integration with their host operating system, <a href="#native-extensions">Native Extensions</a>
          are required.

          Packages can be installed either locally (to a single project) or globally. <code>npm init</code>
          creates a <code>package.json</code> file which is akin to a Ruby project's Gemfile - it lists
          the packages required (including their versions and dependencies) and can distinguish package
          sets between environments like test, production, and development. Packages are saved into
          a <code>.npm-packages</code> in the project (for local installation) or elsewhere (for global
          installations - by default the <code>~</code> home directory). Node projects are distributed with
          a specification file but don't include the bundled dependencies themselves. <code>npm install</code>
          installs the actual dependencies to the developer's computer, though, when run in a project
          directory.

          NPM integrates with Node's <code>require</code> system to make including packages very quick and
          easy. <code>npm install jQuery</code> allows one to simply write <code>$ = require(jQuery)</code>.

          As with Ruby gems, there are <i>tons</i> of useful and interesting Node packages coming out.
          I'm less experienced with the Node's plugin ecosphere than Ruby's, but here are some of the
          major packages I've looked at / tried:

          <a href="#yo-url">Yo</a> - generators for lots of Node projects. These generators aim to be really
          compresive. They often include build and deploy systems configured with the application.
          There are generators for most JS frameworks and for NPM package skeletons,
          jQuery plugins, Chrome extensions, some Ruby frameworks like Sinatra, and many permutations
          of a diverse selection of components combined.

          I've generated a bunch of projects with yo, but haven't gone on to build on the generated
          apps much. I have a lot to learn in the Node world, and there's a good educational benefit
          to adding components incrementally. Perhaps when my Node workflow becomes further streamlined
          I will be more effective with Yo.

          <a href="#grunt-url">Grunt</a> - A powerful "build system", i.e. an automated task runner.
          Here's some tasks Grunt might be used for:
            - Running a test suite and automated code review
            - Running preprocessors (Coffeescript to Javascript,SASS to CSS, Markdown to HTML, etc)
            - Minifying and compressing assets (CSS, JS, images)
            - Deploying to sandbox / production servers
            - Backing up a database
          More broadly, though, a Grunt task could perform arbitrary tasks like a
          shell script would. They can also be scheduled to run on intervals.



      </pre>

  </section>

  <section class="css" id="css">
    <p><b>HTML / CSS</b></p><pre>


        HTML is the "skeleton" of a page. It contains unstyled content. Sometimes,
        with a bad internet connection, pages will fail to load CSS and users see the
        page's content, but everything is quite ugly. Content is usually stacked to
        the left side of the screen, the background is white and text is black.
        Some content shows up, but much doesn't. This
        is the HTML by itself.

        Websites are generally constructed with a HTML skeleton, CSS styles,
        and more complex interactivity in Javascript.

        HTML offers a lot for website building without CSS and Javascript, though.
        There are preset styles for many elements. Furthermore, effective CSS relies
        on a confident understanding of the default style effects of HTML elements.
        For example, the <code>pre</code> tag signifies "preformatted" text - text in this
        tag will have newlines and indentation preserved.
        Most of the content on this site
        is contained in pre tags, for example. Other tags, like <code>p</code> (paragraph),
        don't respect newlines and indentation. There are many more examples,
        such as <code>b</code> (bold), <code>i</code> (italic), the distinction between <code>block</code>
        and <code>inline</code> display types, <code>font-size</code>, and many more.

        There are a lot of nuances to good HTML code, and I tend to use libraries for
        these effects. As with Javascript and CSS, a big issue is compatibility between
        browsers. A "Shim" (particular command that, when commented out, is still
        interpreted by older browsers) can be used for "<a href="#progressive-enhancement-url">progressive enhancement</a>"
        (or "<a href="#graceful-degredation-url">graceful degredation</a>").
        There is also the issue of viewport resizing, key to "responsive" websites
        which change the content's presentation depending on which size screen the
        user's computer has. All non-inline CSS and Javascript is ultimately included through
        the HTML document through requiring the files in <code>script</code> and <code>link</code> tags.
        I know <a href="#polymer-url">Polymer</a> is a project to assist in making
        custom HTML elements, and <a href="#DOM-url">the DOM</a> is a very complex area I could learn more
        about.

        CSS isn't responsible for all "style" on the web - Javascript is capable of making
        very complex visual effects (<a href="#d3-url">D3</a>, <a href="#canvas-url">Canvas</a>, etc.)

        Here is a good tutorial for learning CSS: <a href="#css-food-tutorial-url">Good CSS Tutorial</a>.

        CSS color names are useful, but also mildly entertaining: <a href="#css-color-names-url">CSS Color Names</a>.

        There are many libraries and programs which help write HTML and CSS.
        For CSS, there are preprocessors like <a href="#sass-url">SASS</a> and <a href="#less-url">Less</a>.
        I haven't looked much at Less, and I've used SASS but don't really
        find it offers too dramatic a benefit over normal CSS.
        I understand that features such as nested styles and mixins are useful, but my troubles with
        CSS are generally the result of misunderstanding the effects of style rules, not with
        writing code that is too verbose.

        I find that with using CSS libraries found on the internet, it's often hard to refactor
        or experiment with new features. This is why, for personal projects, I tend
        not to use CSS libraries / components (such as <a href="#bootstrap-url">Bootstrap</a>). I understand the
        need to make sites look good, though. It's easy to buy incredible CSS
        templates through sites like <a href="http://themeforest.net">ThemeForest</a>.

        There's also many Javascript / jQuery plugins which work in conjunction with
        HTML and CSS. I look at <a href="#unheap-url">Unheap</a> for these,
        but also anywhere people are discussing new open-source projects.

        <a href="#bootstrap-zero">Bootstrap-Zero</a> is a particularly good source
        for free Bootstrap templates, in my opinion (<a href="#bootstrap-zero-google-cards-url">Google Cards</a> example).

        I am interested in moving more of my HTML / CSS (and JS) workflow to
        WYSIWYG editors for
        the purpose of expediating my front-end productivity. There are companies which make excellent products for this.
        One I've used is <a href="#weebly-url">Weebly</a>, which has a great
        drag-and-drop editor for components. I'm not sure if apps like Dreamweaver
        provide HTML / CSS export, but I'd definitely like to look more into tools that do.

        There are certain CSS features I find offer a lot of bang for the buck:

        <code>transitions</code>

        Example:
        <code>
  .some-class {transition: all 1s ease; border: 1px solid black; width: 50px; height: 50px; }
  .some-class:hover {background: grey}
        </code>
        <style media="screen">
          .some-class {
            transition: all 1s ease;
            border: 1px solid black;
            width: 50px;
            height: 50px;
            position: relative;
            left: 280px;
            bottom: 20px;
          }
          .some-class:hover {background: grey}
        </style>
        ===> (hover over this) <div class="some-class"></div>

        <code>Opacity</code>

        Example:
        <code>
          .background-img {
            background-color: red;
            width: 200px;
            height: 200px;
            padding:50px;
          }
          .opaque-overlay {
            width: 100px;
            height: 100px;
            background-color: white;
            opacity: 0.5;
          }
        </code>
        <style media="screen">
        .background-img {
          background-color: red;
          background-overflow: hide;
          width: 100px;
          height: 100px;
          padding:50px;
          position: relative;
          left: 200px;
          bottom: 20px;
        }
        .opaque-overlay {
          width: 100px;
          height: 100px;
          background-color: white;
          opacity: 0.5;
        }
        </style>
        ==> See here (The smaller square is partly transparent,
        so it's 'white' background color shows up as pink):

        <div class="background-img">
          <div class="opaque-overlay"></div>
        </div>
        <code>Inline-Block</code>

        This helps inline attributes gain block traits without automatically taking up
        a full line line like blocks tend to. It can also be used for block elements to make
        them appear inline. Here's an example of a span element styled using
        inline-block:

        <code>
          .inline-block-span {
            display: inline-block;
            border: 1px solid black;
            padding: 2px;
            background-color: lightgreen;
          }
        </code>
        <style media="screen">
        .inline-block-span {
          display: inline-block;
          border: 1px solid black;
          padding: 2px;
          background-color: lightgreen;
        }
        </style>
          Some normal text - <span class="inline-block-span">I'm an inline block span</span> ... some more normal text


        <code>Box-Shadow, border-radius</code>

        Box shadow is used to give
        a shadow effect on boxes.

        Border radius is used to round
        rectangles into circles.

        <code>

  .sun {
  border: 1px solid black;
  border-radius: 100px;
  box-shadow: 0px 0px 100px black;
  width: 100px;
  height: 100px;
  position: relative;
  left: 100px;
  background-color: yellow;
  border: 10px solid red;
  }

        </code>
        <style media="screen">
        .sun {
          border: 1px solid black;
          border-radius: 100px;
          box-shadow: 0px 0px 100px black;
          width: 100px;
          height: 100px;
          position: relative;
          left: 100px;
          background-color: yellow;
          border: 10px solid red;
        }
        .sun-box {
          width: 500px;
          height: 500px;
          background: orange;
          padding: 50px;
        }
        </style>
        ==> (this is surrounded by an orange div to emphasize the box-shadow
        color transition effect)

        <div class="sun-box">
          <div class="sun"></div>
        </div>




}
    </pre>
  </section>

  <section class="databases" id="databases">
    <p><b>Databases</b></p><pre>


        Databases aren't strictly necessary for data storage. There's always writing and reading
        from file. In Ruby, there's also <code>PStore</code> (<a href="#pstore-url">standard library link</a>) -
        a really useful Standard Library module for storing data to file in a Hash format.
        As far as the standard kinds of databases for public-facing applications, though,
        I'm familiar with SQL and, to a lesser extent, "NoSQL" systems.
        SQL stands for "structured query language" - for databases like <a href="#postgres-url">Postgres</a>,
        <a href="MySQL">MySQL</a>, and <a href="SQLite">SQLite</a>. There are useful GUI programs
        such as  <a href="#postgres-gui-urk">SOME-POSTGRES-GUI</a>, <a href="#sql-workbench-url">SOME-SQL-WORKBENCH</a>, and Ruby also has a
        good interface through <code>DB-RAW-EXECUTE</code>, <code>SomeModel.find_by_sql</code>,
        <code>rails dbconsole</code>, and the <a href="#arel-url">Arel</a>-based ActiveRecord.

        Besides SQL, there's NoSQL which is a realm I haven't too extensively explored. I have
        worked with Redis, though, in my work at Sobrr.life. As I understand it, Redis is quicker
        than SQL, but it is also in a sense more primitive, at least with the configuration I had.
        Perhaps "primitive" isn't the right word for it - for example, <a href="#">this blog post</a>
        on the topic describes how Redis' should ideally be used for "atomic operations", which
        is specifically what we used it for at Sobrr.life - caching of "score" counters for members
        and posts (data which could be recomputed but not conveniently). I have also started learning
        MongoDB in the context of Meteor.

    </pre>
  </section>
  <section class="deployment" id="deployment">
    <p><b>Deployment</b></p><pre>


        I got a lot of experience with deployment when working at Sobrr.life.
        Before I had mostly deployed with Heroku (for personal projects). I've also
        deployed on Github pages -  <a href="#asteroids-url">Asteroids</a> and <a href="#snake-url">Snake</a> HTML5 Canvas games
        and a (inactive) jekyll blog. 
        
        At Sobrr.life, we used <a href="#aws-url">AWS</a> to serve 100,000
        monthly users and thousands of daily users.
        
        Some AWS services we used:
              
        <a href="#ec2-url">EC2</a> - "instances" of machines that the app is installed on. These can be
              SSHd into. Limiting CPU consumption on these machines was important for
              managing the performance of resource-intensive operations such as data
              migrations.
        
        <a href="#s3-url">S3</a> - Asset hosting, e.g. images for user posts. 
             A major feature of the Sobrr app is expiring photo posts.
 
        <a href="#eb-url">Elastic Beanstalk</a> - Autoscaling and groupings of EC2 instances
                            for Sandbox, Staging, and Production environments.
           
        <a href="#cloudwatch-url">Cloudwatch</a> - For storing & visualizing metrics 

        <a href="#elasticache-url">ElastiCache</a> - Redis for caching and queueing.  
        
        <a href="#rds-url">RDS</a> - Relational Database Service. We used MySQL with a hierarichal
              <a>replication</a> system (also known by the term "master-slave", still common
              despite being voted the most politically incorrect word <a href="http://www.seattlepi.com/national/article/Master-slave-named-most-politically-incorrect-1161133.php">in 2004</a>
              by the Global Language Monitor). 



    </pre>
  </section>

  <section class="testing" id="testing">
    <p><b>Testing</b></p>
<pre>

        For tests, I mainly have experience in Ruby, but also a bit in Javascript.
        In Ruby, here are a few of the tools that I have used:

        <a href="#rspec-url">RSpec</a>

        <a href="#selenium-url">Selenium</a>

        <a href="#cucumber-url">Cucumber</a>
        
        In Javscript, I have used <a href="#jasmine-url">Jasmime</a>.
        
        TDD (<a href="#tdd-url">Test Driven Development</a>) was valued at Sobrr.life
        (my last employer). I think the biggest benefit of tests is
        their ability to confirm that existing features aren't broken
        by being refactored or added to.  

</pre>

  </section>

  <section class="linux" id="linux">
    <p><b>Linux</b></p><pre>

          <span>
          I've used Linux for a few years, since right around when I began
          programming. It is free, installation is possible on many machines
          and there's lots of great software for programming and non-programming
          alike. 

          <span>
          Since Linux and Mac are both built on Unix, the same commands work for
          each of them (for the most part). There's also the <a href="#apt-url">APT</a> software repository
          specific to my choice Linux "distribution", Ubuntu. There's still a lot for
          me to learn with system administration and Linux commands. I prefer <a href="#nano-url">Nano</a>
          to <a href="#vim-url">Vim</a>, for example. Still I enjoy learning about Linux commands and programs.
          </span><span>Ruby is nicely suited to shell programming automation, as any commands
          within <code>``</code> backticks will be delegated to the system.

          <span>Inspired by <a href="http://www.reddit.com/r/unixporn">reddit.com/r/unixporn</a>, I'm currently trying out a "tiling" desktop
          environment with <a href="#awesome-url">Awesome Window Manager</a>.     
          </span>
          <span>I'm running Ubuntu 14.01 on a Chromebook using <a href="#crouton-url">Crouton</a>. This setup
          makes it easy to switch back and forth between the Ubuntu GUI and ChromeOS's.
          ChromeOS is built with Linux and offers performant virtualization for other Linux
          systems. With this setup, I can switch between the ChromeOS and Ubuntu GUIs
          with a keyboard shortcut. I can also connect with the Ubuntu machine from a
          terminal tab in ChromeOS and access port processes (i.e. local HTTP servers)
          from ChromeOS.
          </span>

</pre>
  </section>

  <section class="world" id="world">
    <p><b>The World at Large</b></p> <br>
    <pre>
          I have a B.A. in Politics from UC Santa Cruz, and it's still a major interest of
          mine. I will be eventually filling a blog at <a href="http://maxpleaner.ghost.io">maxpleaner.ghost.io</a> with thoughts
          on current events. I'm interested in pacifism, social stratification, urbanization,
          <a href="http://en.wikipedia.org/wiki/World-systems_theory">world systems</a>, and the normalization of virtual reality.
  </pre>
  </section>
</section>

<section>
  <div class="experience" id="experience">
    <p><b>Experience</b></p> <br>
    <pre>
    I'm from San Francisco, and went to UC Santa Cruz for college.
    I was undeclared for a while with the intention of choosing
    a STEM major, then switched to Linguistics before finally
    switching to Politics. After finishing college, I started
    studying computer programming with an emphasis on web
    development.

    Prior to programming, I had a lot of professional experience
    in the non-profit / politics realm. I did canvassing to
    fundraise for nonprofits, gathered signatures for dozens
    of California ballot initialitives, polled voters for
    a mayoral campaign, and staffed a City Council member's office in
    Santa Cruz. I scoped ice cream and made sandwiches, too.

    When I returned to San Francisco after graduating, I was
    discovered that there were a lot of community resources
    for beginning to study web development. I was interested in
    the "boot camps", but I was also confident in my independent
    learning abilities and wanted to explore the field more
    independently at first. I followed free curriculums which
    introduced me to Ruby, HTML, CSS, Javascript, Git, Unix, etc.
    such as <a href="#odin-url">The Odin Project</a>.

    Eventually I started to feel like my questions were becoming
    more nuanced and I could benefit from more extensive dialog with
    a teacher. I was still a bit ambivalent about the bootcamps
    because I wasn't sure the pressure of an 80+ hour work week
    was worth it. It had been nearly a year since I began studying
    full-time, though, and although I was eager to work, I felt
    as though I still needed some more educational experience
    before I dove into the job market.
    I joined <a href="#codeunion-url">CodeUnion</a>'s first
    class. It appealed to me for a few reasons. It was a 6 person
    group with 2 teachers, one of whom wrote much of the curriculum
    for DevBootcamp, a reputable bootcamp. It would teach <a href="https://sinatrarb.com">Sinatra</a>,
    which, unlike Rails, would be completely new to me. It was
    a great class and the positive experience gave me the confidence
    to apply to some bootcamps.

    I got into App Academy, my top choice since it has a good
    reputation and a progressive tuition model (based on
    the post-graduation salary achieved). In my three months there,
    I learned tons and gained a way more "comprehensive
    "full-stack" skillset. A lot of the topics in my
    <a href="http://maxp-homepage.heroku.com">Skills</a> section were developed there. My experience
    studying independently also proved valuable, though. The topics
    I'd been studying complemented the skills I gained, and my
    confidence grew that I would be well equipped to continue to
    gain new web web development skills as I transitioned into
    the Software Engineer's career.

    Not long after, I began my first developer job at Sobrr.life
    a small, seed-funded startup in San Francisco. I was the
    main programmer for logic updates on the Rails back end team,
    configuring data sent to to iOS and Android apps (with thousands of
    daily active users).

    Some of the topics I worked on:

    &bull; configured REST endpoints, pagination cursors, JSON
    responses, language detection, and moderation rules

    &bull; managed databases and deploys

    &bull; built Javascript features for the promotional website -
      an administration interface and infinite-scroll with a responsive
      pinterest-style grid (see <a href="http://app.sobrr.life/presentation/around_feeds">the site</a>).

    &bull; set up delayed jobs (via the <a href="#Resque-url">Resque</a> Redis queueing library)
    for sending automated chats and MPN push notifications at
    scheduled times.

    &bull; used <a href="#redis-url">Redis</a> to cache data for efficiency gains (including
    ActiveRecord model configuration, writing rake tasks for data
    migration, and using the <a href="#redis-objects-url">RedisObjects</a> and <a href="#redis-gem-url">Redis.rb</a> gems
    for programming Redis with Ruby methods.)

  Every day was different and the experience
  was invaluable. The company's development operations have since
  relocated overseas.

  I've recently relocated to Portland from San Francisco and I'm
  currently seeking new work here or virtually. See the
  <a href="http://maxp-homepage.heroku.com/#links">Links</a> page to contact me, and please do.



    </pre>
    </div>
</section>

<section>
  <div class="links" id="links">
    <p><b>Links</b></p> <br>
      <a href="http://github.com/maxpleaner">Github</a> <br> <br>
      <a href="http://linkedin.com/in/maxpleaner">LinkedIn</a> <br><br>
    <!--  <a href="#blog-1-url">Blog1</a> <br><br>-->
    <!--  <a href="#blog-2-urk">Blog2</a>-->
  </div>
</section>
