<!--  hidden by JS -->
<!--  .js-test-hidden -->
<div class="js-test-hidden">
  <h1>YOU DON"T HAVE JAVASCRIPT, WHICH IS REQUIRED FOR FUNCTIONAL LINKS & CONTENT REORDERING</h1>
</div>

<div class="header">
  <section class="intro">
    <b> Max Pleaner </b> <br><br>
    <i> <small>Web Developer / Software Engineer </small></i>
  </section>
  <br>
  <hr>
  <br>
  <section class="primary-links">
    <a class="clickable" data-target="skills" href="#skills">Skills</a>
    <a class="clickable" data-target="experience" href="#experience">Experience</a>
    <a class="clickable" data-target="links" href="#links">Links</a>
  </section>
   <br>
</div>

<!--  .focus-area-1 -->
<!--  .focus-area-2 -->
<section class="focus-area-1"></section><br>
<section class="focus-area-2"></section>

<!--  .skills -->
<!--  .clickable -->
<!--  data-target -->
<section class="skills" id="skills">
  <p><b>Skills</b></p> <br>
  <a class="clickable" data-target="ruby" href="#skills/ruby">Ruby</a>
  <a class="clickable" data-target="javascript" href="#skills/javascript">Javascript</a>
  <a class="clickable" data-target="databases" href="#skills/databases">Databases</a>
  <a class="clickable" data-target="deployment" href="#skills/deployment">Deployment</a>
  <a class="clickable" data-target="testing" href="#skills/testing">Testing</a>
  <a class="clickable" data-target="linux" href="#skills/linux">Linux</a>
  <a class="clickable" data-target="world" href="#skills/world">The World
   at Large</a>
</section>

<!--  .skill-details -->
<section class="skill-details">
  <section class="ruby" id="ruby">
    <p><b>Ruby</b></p>
    <p>
      <pre>
I haven't seen any such code that maintains a poetic natural language sensibility in the way Ruby does. Some insist that this comes at a price. For example, Ruby's "<a href="http://en.wikipedia.org/wiki/Duck_typing ">duck-typing</a>" system can be seen as allowing errors to propagate unnecessarily farther than where they originated. It allows for a lot less redundancy, though, if the reader/author can keep track of variable types. I've found Ruby's stack traces to be quite comprehendable and helpful.

<b><a href="http://rubyonrails.org/">Rails</a></b>

Rails is the web framework I'm quickest and most fluent in. I don't think Rails is the end-all for web development. With more fluency, I'm sure I could write a complex single-page app faster with a Node framework. For mostly everything besides asynchronous server calls and client-side page navigation, though, I'm quickest with Rails.

A few topics of Rails development:

<b>Auth </b>- Session tokens, authenticity tokens, and encrypted passwords can be be added to Rails rather quickly. There are also gems like <a href="https://github.com/plataformatec/devise">Devise</a> which add this functionality, and <a href="http://oauth.net/">OAuth</a> libraries for many providers like Github, Twitter, etc.. There can be a lot that goes into a complex auth system, such as email confirmation, password retrieval, etc.

<b>Code Organization</b> - I've since come to appreciate the 'convention over configuration' approach,  which enhances components' portability among projects and helped me get productive on a large codebase like Sobrr.life quickly.

<b>Generators</b> - <code> rails new </code> is a generator for a new project. For some projects (like this site, which is mainly HTML, CSS and JS), this is nearly all the code the server needs in development mode. There are also generators for models, controllers, database migrations, <a href="http://en.wikipedia.org/wiki/Rake_%28software%29">rake tasks</a>, and, my favorite, scaffolds, which produce a working <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> app with front-end. Generators excite me not just because of laziness but also because of their potential to facilitate metaprogramming. There's a project called <a href="http://prelang.com/">Prelang</a> which lets you describe your app's specs in a web interface and generates a rails project for you. <a href="http://www.meteorkitchen.com/">Meteor Kitchen</a> is a similar tool for Javascript.

<a href="http://www.sinatrarb.com/">Sinatra</a>

Sinatra shares a lot in common with Rails but is much more minimalist. It's less 'opinionated' than Rails, and since projects are built more from-the-ground-up, there's less deconstruction required to change out core components. Sinatra's routing pattern, <code>get ("/") do
  puts "hello world"
end</code>, is found in lots of Ruby's web "microframeworks".

<a href="http://www.rubygems.org/">Gems</a>

Gems are Ruby's plugin system, managed with <a href="https://rvm.io/">RVM</a> (or <a href="https://github.com/sstephenson/rbenv">rbenv</a>), <a href="https://rubygems.org/">RubyGems</a>, <a href="http://bundler.io/">Bundler</a>, etc. Interesting gems are constantly coming out. The site <a href="http://gembundle.com">GemBundle</a> is useful for discovering them.

Here are a few I like:
<span><span>
<a href="https://github.com/defunkt/colored">Colored</a> - This Gem enables string methods like <code>"string".red</code>, <code>"string".bold.underline</code>, <code>"string".white_on_red</code>, etc. It uses <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">ANSI Escape Codes</a> (ANSI stands for American National Standards Institute) so the text appears colored when it's printed in the terminal. The actual text saved to file, though, is wrapped in encoding characters. For example, <code>"string".red</code> would produce <code>\e[31mstring\e[0m</code>. Most of the time when I make CLI applications, I use this gem. There's also a Javascript library called <a href="https://github.com/drudru/ansi_up">Ansi Up</a> which converts ANSI-encoded text into <code>span</code> elements with corresponding CSS coloring. Together they make a handy way to define styles from the server.

Example:
<span class="ansi"><%= ".red_on_yellow".red_on_yellow %></span>
<span class="ansi"><%= ".green_on_black".green_on_black %></span>
</span><span>
<a href="https://github.com/deivid-rodriguez/byebug">Byebug</a> - This makes it possible to place breakpoints in code and step through, inspecting values and running code in a REPL. It is similar to the "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">debugger</a>" breakpoit tool for Javascript in major browsers. There are also powerful features I haven't used, such as changing source code on-the-fly. It's vast improvement to debugging with "puts" statements.
</span><span>
<a href="http://opalrb.org/">Opal</a> - Opal compiles Ruby to Javascript and can even compile to Javascript libraries like jQuery. <a href="http://voltframework.com/">Volt</a> is a framework built with Opal that features <a href="http://stackoverflow.com/questions/13504906/what-is-two-way-binding">2-way-data binding</a>. I'm eager to look into these tools more.
</span><span>
<a href="https://github.com/rest-client/rest-client">Rest Client</a> - helps configure HTTP methods (with an emphasis on the  <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">Representational State Transfer</a> design pattern), including parameters, headers, etc.

A basic example is <code>RestClient.get "http://wikipedia.com"</code> which will give a text version of the file a browser would receive if that url were entered in the address bar.
</span> <span>
<a href="https://github.com/nokogiri/nokogiri">Nokigiri</a> - DOM parsing for the Ruby server. <code>Nokigiri.parse(html).css</code> allows for selecting objects from the DOM like <code>$('.some-css-class')</code> does in jQuery. It's useful for web scraping.
</span>
</span>

      </pre>
    </p>
  </section>

  <section class="javascript" id="javascript">
    <p><b>Javascript</b></p><pre>
I've been learning & working with Javascript since soon after I began programming.

The language in some ways seems more primitive than Ruby. Alot of convenience methods in Ruby (<code>map</code> and <code>reject</code> for example) aren't defined in plain JS. They are defined in libraries like <a href="http://oauth.net/">underscore</a>, though.

Javascript has a better system for passing around functions as arguments (callbacks), though. In Ruby, there are special types / keywords for this - <code>yield</code>, <code>Proc</code>, <code>Lambda</code>, etc. In Javascript, there's a single type (a 'function') . Another benefit of Javascript is the open access to define attributes on arbitrary objects. It's be like if Objects in Ruby were by default <code>OpenStruct</code> objects.

Javascript also provides a ubiquitous interface with the browser DOM. A conventional complex web app will certainly use Javascript for the front-end.

<b><a href="http://jquery.com">jQuery</a></b> - A very useful abstraction for DOM methods. One could write Javascript equivalents for jQuery methods (<a href="http://youmightnotneedjquery.com">youmightnotneedjquery.com</a>), but I find it a useful abstraction. <a href="http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014">jQuery's blog</a> says that it's used by 60% of the top 100,000 websites.

<code>$.ajax</code>, <code>$.get</code>, <code>$.post</code>, etc. can be used for making AJAX calls to the server.

<code>$.('.css-selector')</code> can be used to select DOM elements using class, ID or attribute. This replaces Javascript's <code>getElementByID</code>, <code>getElementsByClassName</code> or <code>querySelector</code> methods on the <code>document</code> object.

<code>$(".selector").on("event", function(event) { ... event code ... })</code> provides event handlers for <code>click</code>, <code>hover</code>, <code>submit</code>, window scrolling, etc.

<code>hide()</code>, <code>show()</code>, and <code>fadeOut()</code>, <code>fadeIn()</code> provide CSS effects & transitions.

<code>clone()</code>, <code>remove()</code>, and <code>empty()</code> are among the many other useful methods.

<b>
<a href="http://coffeescript.org/">Coffeescript</a> </b>

Coffeescript compiles to Javascript. Unlike SASS, which compiles to CSS but accepts any CSS as valid, plain Javascript wouldn't be valid in Coffeescipt. Coffeescript's syntax is meant to be less verbose than Javascript's. It ends up looking more similar to Python or Ruby. Features distinguishing it from Javascript include:
- many <code>()</code> parentheses are optional, and so are <code>{}</code> curly brackets.
- Indentation is used to delimit blocks / scope (as in Python).
- There is a <code>functionVariable = (arg) -> console.log(arg) </code> shorthand for functions that is similar to Ruby's <code>function_variable = ->(arg) { puts arg }</code> lambda shorthand.
</b>
<b>
<a href="http://backbonejs.org/">Backbone</a></b>

Backbone is a client-side Javascript MVC.

- The <a href="https://github.com/meleyal/backbone-on-rails">backbone-on-rails</a> Ruby gem provides a <code>rails generate backbone:install</code> command which sets up a basic directory structure and some boilerplate code for consuming Rails' JSON API as a backend for Backbone
- Backbone has it's own router, with routes navigatable via the <code>#</code> url fragment.
- HTML templates can use <a href="http://www.embeddedjs.com/">EJS</a> (embedded Javascript), which provides an <a href="http://en.wikipedia.org/wiki/ERuby">ERB</a>-like syntax for programmatic control over HTML.
- Events are registered in a clean DSL, <code>events: {"click button.upvote": sendUpvote }</code>.
- Subviews can add a lot of modular control over front-end components. Libraries like <a href="http://marionettejs.com/">Marionette</a> are built for subviews, but I've preferred a hand-rolled system written as part of the App Acadamey curriculum.

A major main benefit of single-page-apps is the ability for clients to interact with servers without the need for  full page reloads, like websites traditionally have. AJAX (or WebSockets, etc) is used to send HTTP requests in the background. This is more efficient, more user-friendly, and enables web apps to function more like native apps.
</b>
<b>
<a href="https://www.meteor.com/">Meteor</a>
</b>
I've began learning and building with Meteor since it offers an integrated server-client system which is intended for single-page-app development.

This certainly isn't unique to Meteor. The <a href="http://mean.io/#!/">MEAN</a> stack is more widely used and integrates an <a href="https://angularjs.org/">Angular</a> front-end with <a href="http://expressjs.com/">Express</a> / <a href="https://www.mongodb.org/">MongoDB</a> backend running on Node. Meteor entices me becuase of it's comprehensive scope and emphasis on reducing boilerplate code for client-server communication and DOM updates. Meteor's team made it's own <a href="https://www.meteor.com/ddp">DDP</a> data communiction protocol for two-way data binding.

The world of single-page-apps is growing rapidly and is accompanied by the emergence of new frameworks. I can't help but pay attention to the seeming politics of their hierarchy. Angular's development is funded <a href="#angular-funding-url">by Google</a>, and React <a href="#react-url">by Facebook</a>. Meteor comes across as trying to insulate the developer from a myriad of options. They offer freemium hosting and there is a Meteor-only package manager built on top of NPM called <a href="#meteorite-url">Meteorite</a>. In the competitive atmosphere, though, surely frameworks will continue to "one-up" each other for some time.

Still, Meteor's packages are strikingly effortless to set up. To add authentication via password or OAuth provider, simply adding a meteor package like <code>meteor add accounts-password</code> or <code>meteor add accounts-github</code> will set up the backend and one can add a front-end with only <code>meteor add accounts-ui</code> and <code>{{>loginButtons }}</code>.


</b>
<b>
<a href="https://www.npmjs.com/">NPM</a>
</b>

NPM, 'Node Package Manager', is akin Ruby Gems in many ways. 

Packages are installed into a <code>.npm-packages</code> directory globally or locally to a single project. <code>npm init</code> creates a <code>package.json</code> comparable to a Ruby project's Gemfile - it lists the packages required (including their versions and dependencies) and can distinguish package sets between environments like test, production, and development. Node projects are distributed with a specification file but don't include the bundled dependencies themselves. <code>npm install</code> installs the actual dependencies.

NPM integrates with Node's <code>require</code> system to make including packages very quick and easy. <code>npm install jQuery</code> allows one to simply write <code>$ = require(jQuery)</code>.

As with Ruby gems, there are many useful and interesting Node packages coming out:

<a href="http://yeoman.io/">Yo</a> provides generators for lots of Node projects. They often include build and deploy systems configured with the application. There are generators for most JS frameworks and for NPM package skeletons, jQuery plugins, Chrome extensions, some Ruby frameworks like Sinatra, etc.

<a href="http://gruntjs.com/">Grunt</a> is a "build system" / automated task runner. Here are some tasks Grunt might be used for:
- Running a test suite and automated code review
- Running preprocessors (Coffeescript to Javascript,SASS to CSS, Markdown to HTML, etc)
- Minifying and compressing assets (CSS, JS, images)
- Deploying to sandbox / production servers
- Backing up a database
More broadly, though, a Grunt task could perform arbitrary tasks like a shell script would. I haven't actually done this, but the <a href="https://github.com/sindresorhus/grunt-shell">grunt-shell</a> packages looks quite useful. They can also be scheduled to run on intervals.



      </pre>

  </section>

  <section class="databases" id="databases">
    <p><b>Databases</b></p><pre>
A simple storage system is Ruby's <a href="http://ruby-doc.org/stdlib-2.1.2/libdoc/pstore/rdoc/PStore.html">PStore</a>, which is included in the Standard Library and provides an interface for saving the state of a Hash to file.

I'm also familiar with some SQL and NoSQL.

Ive used SQL with databases like <a href="http://www.postgresql.org/">Postgres</a>, <a href="https://www.mysql.com/">MySQL</a>, and <a href="https://www.sqlite.org/">SQLite</a>.

At Sobrr.life, I administered databases with large data-sets. I optimized queries, migrated data, and cached via Redis.

NoSQL systems I've worked with include <a href="http://www.infoworld.com/article/2608293/nosql/how-json-sparked-nosql----and-will-return-to-the-rdbms-fold.html">JSON</a>, <a href="http://yaml.org/">YAML</a>, <a href="http://redis.io/">Redis</a>, and some <a href="https://www.mongodb.org/">MongoDB</a>. I've also used <a href="https://github.com/resque/resque">Resque</a>, an application process queueing system built on Redis.

Ruby's <a href="https://github.com/rails/arel">Arel</a>-based <a href="https://github.com/rails/rails/tree/master/activerecord">ActiveRecord</a> is a Ruby library for abstracting vendor-specific SQL syntax. It's queries are far more human-readable queries than SQL's, but are still highly optimizable.

    </pre>
  </section>
  <section class="deployment" id="deployment">
    <p><b>Deployment</b></p><pre>
Before working at Sobrr.life, I had mostly deployed with Heroku for personal projects. I'd also deployed on Github pages - <a href="https://maxpleaner.github.io/asteroids">Asteroids</a> and <a href="https://maxpleaner.github.io/snake">Snake</a> HTML5 Canvas games and a (inactive) jekyll blog.

At Sobrr.life, we used <a href="http://aws.amazon.com/">AWS</a> to serve 100,000 monthly users and thousands of daily users.

Some AWS services we used:

<a href="http://aws.amazon.com/ec2/">EC2</a> - "instances" of machines that the app is installed on. These can be SSHd into. Limiting CPU consumption on these machines was important at Sobrr.life for managing the performance of resource-intensive operations such as data migrations.

<a href="http://aws.amazon.com/s3/">S3</a> - Asset hosting, e.g. images for user posts. A major feature of the Sobrr app is expiring photo posts.

<a href="http://aws.amazon.com/elasticbeanstalk/">Elastic Beanstalk</a> - Autoscaling and groupings of EC2 instances for Sandbox, Staging, and Production environments.

<a href="http://aws.amazon.com/cloudwatch/">Cloudwatch</a> - For storing & visualizing metrics

<a href="http://aws.amazon.com/elasticache/">ElastiCache</a> - Redis for caching and queueing.

<a href="http://aws.amazon.com/rds/">RDS</a> - Relational Database Service. We used MySQL with a hierarchichal <a>replication</a> system (also known by the term "master-slave", still common despite being voted the most politically incorrect word <a href="http://www.seattlepi.com/national/article/Master-slave-named-mos -politically-incorrect-1161133.php">in 2004</a> by the Global Language Monitor).


    </pre>
  </section>

  <section class="testing" id="testing">
    <p><b>Testing</b></p>
<pre>For tests, I mainly have experience in Ruby, but also a bit in Javascript. In Ruby, here are a few of the tools that I have used:

<a href="http://rspec.info/">RSpec</a> as the basis for tests.

<a href="https://github.com/jnicklas/capybara">Capybara</a> for browser automation.

<a href="https://cucumber.io/">Cucumber</a> for integration tests.

In Javascript, I have used <a href="http://jasmine.github.io/">Jasmime</a>.

TDD (<a href="http://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>) was valued at Sobrr.life (my last employer). I think the biggest benefit of tests is their ability to confirm that existing features aren't broken by being refactored or added to.

</pre>

  </section>

  <section class="linux" id="linux">
    <p><b>Linux</b></p><pre>
I've used Linux for a few years, since right around when I began programming. It is free, installation is possible on many machines and there's lots of great software for programming and non-programming alike.

Since Linux and Mac are both built on Unix, for the most part one can use the same commands on each of them. The <a href="http://en.wikipedia.org/wiki/Advanced_Packaging_Tool">APT</a> software repository specific to my systems' Linux distribution, Ubuntu, makes installing lots of programs easy.

</span><span>Ruby is nicely suited to shell programming automation, as any commands within <code>``</code> backticks will be delegated to the system.

I'm running Ubuntu 14.01 on a Chromebook using <a href="https://github.com/dnschneid/crouton">Crouton</a>. ChromeOS is built with Linux and offers performant virtualization for other Linux systems. With this setup, one can switch between the ChromeOS and Ubuntu GUIs with a keyboard shortcut, connect to the Ubuntu CLI from a browser tab in ChromeOS and access Ubuntu port processes (e.g. local HTTP servers) from ChromeOS. I also sometimes use cloud machines like <a href="nitrous.io">Nitrous.io</a>.

</pre>
  </section>

  <section class="world" id="world">
    <p><b>The World at Large</b></p>
    <pre>
I have a B.A. in Politics from UC Santa Cruz, and it's still a major interest of mine. I will be eventually filling a blog at <a href="http://maxpleaner.ghost.io">maxpleaner.ghost.io</a> with thoughts on current events. I've been recently thinking about urbanization, <a href="http://en.wikipedia.org/wiki/World-systems_theory">world systems</a>, and <a href="http://en.wikipedia.org/wiki/Computer-mediated_reality">computer-mediated reality</a>.
  </pre>
  </section>
</section>

<section>
  <div class="experience" id="experience">
    <p><b>Experience</b></p> <br>
    <pre>
- I'm from San Francisco

- Prior to programming, I had a lot of professional experience in the non-profit / politics area.

- I did canvassing to fundraise for nonprofits, gathered signatures for dozens of California ballot initiatives, polled voters for a mayoral campaign, and staffed a City Council member's office in Santa Cruz.

- I got a Politics B.A. from UC Santa Cruz for college.

- After finishing college, I started studying web development

- I followed free curriculums which introduced me to Ruby, HTML, CSS, Javascript, Git, Unix, etc. such as <a href="http://www.theodinproject.com/">The Odin Project</a>.

- Eventually I began to feel like my questions were becoming more nuanced and I could benefit from more extensive dialog with a teacher.

- I joined <a href="http://codeunion.io/">CodeUnion</a>'s first class.

- I learned <a href="https://sinatrarb.com">Sinatra</a>, which, unlike Rails, was totally new to me.

- Soon after, I attended <a href="http://appacademy.io/#curriculum">App Academy</a>. In my three months there, I gained a more comprehensive 'full-stack' skillset.

- I then began my first developer job at Sobrr.life, a small, seed-funded startup in San Francisco.

- I was the main programmer for logic updates on the Rails back end team, configuring data sent to to iOS and Android apps (with thousands of daily active users).

- The development cycle was rapid, but some of the features I worked on were:

&bull; REST endpoints, pagination cursors, JSON responses, language detection, and moderation rules.

&bull; managed databases and deploys

&bull; Javascript features for the promotional website - an administration interface and infinite-scroll with a responsive pinterest-style grid (see <a href="http://app.sobrr.life/presentation/around_feeds">the site</a>).

&bull; delayed jobs (via the <a href="https://github.com/resque/resque">Resque</a> Redis queueing library) for scheduling chats and MPN push notifications.

&bull; caching using <a href="http://redis.io">Redis</a> built on ActiveRecord, including rake tasks for data migration.

- The company's development operations have since relocated overseas.

- I've recently relocated to Portland from San Francisco and I'm currently seeking new work here or virtually. See the <a href="http://maxp-homepage.heroku.com/#links">Links</a> page to contact me.

    </pre>
    </div>
</section>

<section>
  <div class="links" id="links">
    <p><b>Links</b></p> <br>
    <pre><a href="http://github.com/maxpleaner">Github</a>
    
<a href="http://linkedin.com/in/maxpleaner">LinkedIn</a>

Email: <a href="mailto:maxpleaner@gmail.com">maxpleaner@gmail.com</a>
    <!--  <a href="#blog-1-url">Blog1</a> <br><br>-->
    <!--  <a href="#blog-2-urk">Blog2</a>-->
    </pre>
  </div>
</section>
